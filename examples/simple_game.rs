use bevy::prelude::*;
use bevy_spacetimedb_wasm::*;
use serde::{Deserialize, Serialize};

// This would normally be generated by `spacetime generate --lang=rust`
// For this example, we're defining the types manually

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Player {
    pub id: u64,
    pub name: String,
    pub x: f32,
    pub y: f32,
}

impl TableRow for Player {
    const TABLE_NAME: &'static str = "players";
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Lobby {
    pub id: u64,
    pub name: String,
    pub player_count: u32,
}

impl TableRow for Lobby {
    const TABLE_NAME: &'static str = "lobbies";
}

// Define reducers using the macro
define_reducer!(SpawnPlayer(name: String, x: f32, y: f32));
define_reducer!(MovePlayer(id: u64, x: f32, y: f32));
define_reducer!(DeletePlayer(id: u64));

fn main() {
    App::new()
        .add_plugins(DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                title: "Bevy SpacetimeDB WASM Example".into(),
                resolution: (800.0, 600.0).into(),
                ..default()
            }),
            ..default()
        }))
        // Add the SpacetimeDB plugin
        .add_plugins(
            StdbPlugin::default()
                .with_uri("ws://localhost:3000")
                .with_module_name("my_game")
                // Register tables
                .add_table::<Player>()
                .add_table::<Lobby>()
        )
        // Add systems
        .add_systems(Startup, setup)
        .add_systems(Update, (
            handle_connected,
            handle_player_inserted,
            handle_player_updated,
            handle_player_deleted,
            spawn_player_on_input,
        ))
        .run();
}

fn setup(mut commands: Commands) {
    // Spawn a camera
    commands.spawn(Camera2d);

    info!("Game initialized! Waiting for SpacetimeDB connection...");
}

fn handle_connected(mut events: EventReader<StdbConnectedEvent>) {
    for _event in events.read() {
        info!("Connected to SpacetimeDB!");
    }
}

fn handle_player_inserted(mut events: EventReader<InsertEvent<Player>>) {
    for event in events.read() {
        info!("Player inserted: {:?}", event.row);
        // Here you would spawn a sprite or entity representing the player
    }
}

fn handle_player_updated(mut events: EventReader<UpdateEvent<Player>>) {
    for event in events.read() {
        info!("Player updated: {:?} -> {:?}", event.old, event.new);
        // Here you would update the player's position/state
    }
}

fn handle_player_deleted(mut events: EventReader<DeleteEvent<Player>>) {
    for event in events.read() {
        info!("Player deleted: {:?}", event.row);
        // Here you would despawn the player entity
    }
}

fn spawn_player_on_input(
    keyboard: Res<ButtonInput<KeyCode>>,
    stdb: Res<StdbConnection>,
) {
    if keyboard.just_pressed(KeyCode::Space) {
        info!("Spawning player...");

        // Call the SpawnPlayer reducer
        if let Err(e) = stdb.reducers().call::<SpawnPlayer>((
            "Player".to_string(),
            0.0,
            0.0,
        )) {
            error!("Failed to call SpawnPlayer reducer: {:?}", e);
        }
    }
}
